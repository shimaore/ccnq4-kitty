The purpose here is to get events out of the async notifications from the servers.

Current state
=============

Modules that report events:

- tangible
- huge-play (via thinkable-ducks) (also provides for black-metal, tough-rate)
- ccnq4-opensips
- nifty-ground
- clever-note / capable-note (retrieve some state? or just push data upstream?)

huge-play
---------

### upstream

(See https://github.com/shimaore/huge-play/blob/master/README-events.md )

- generated by the modules
- sent through statistics.emit (either `report` or `queueur`)
- [needy-toothpaste](https://github.com/shimaore/needy-toothpaste/blob/master/middleware/local_redis.coffee.md) then sends to local redis
- clever-note [retrieves from local redis](https://github.com/shimaore/clever-note/blob/master/redis-source.coffee.md) and [sends upstream](https://github.com/shimaore/clever-note/blob/master/socketio-sink.coffee.md) via socket.io-emitter

### downstream

- [place-call](https://github.com/shimaore/huge-play/blob/master/middleware/client/place-call.coffee.md), [conference](https://github.com/shimaore/huge-play/blob/master/middleware/client/conference.coffee.md) and [queuer](https://github.com/shimaore/huge-play/blob/master/middleware/client/queuer.coffee.md) use `@socket.on`, `@register` (which is `@socket.emit 'register'` in middleware/setup);
- [thinkable-ducks/notify](https://github.com/shimaore/thinkable-ducks/blob/master/notify.coffee.md) uses cfg.notify (i.e. socket.io, backend-side, as defined in [spicy-action/internal-message-broker](https://github.com/shimaore/spicy-action/blob/master/internal-message-broker.coffee.md))


ccnq4-opensips
--------------

- we use the `notify` (Socket.IO, backend-side/internal-broker) bus directly

nifty-ground
------------

- uses `socket.io-client` to connect to `SOCKET` (uses the backen-side/internal-broker)

tangible
--------

Tangible supports multiple logging methods, but it especially supports the thinkable-ducks `notify` scheme.

However integrating with a new transport should be straighforward, they are already many transports (gelf, …).

Future state
============

- It probably makes sense to decouple locally (i.e. use local-redis as local broker).
- This means migrate:
  - ensure all functions provide a `key` and `rev` (I believe — need to really formalize this);
  - huge-play receiver to use local-redis (probably add in needy-toothpaste); get rid of `notify` in thinkable-ducks?
  - ccnq4-opensips receiver and sender to use local-redis
  - nifty-ground receiver and sender to use local-redis
  → project `red-rings` to be used on the backend clients.
- And:
  - have a separate process (e.g. clever-note, or new process) handle the interface with abrasive-ducks (using axon, whatever);
  - and/or front-end redis with stunnel (`verifyPeer = yes`) and have abrasive-ducks connect to redis directly (see [ioredis' TLS options](https://www.npmjs.com/package/ioredis#tls-options));
  - the above options are not exclusive, it can be mix-and-match.
- Also keep backward-compatibility for migration purposes (so probably a separate process using clever-note to get started).

- Finally, in order to optimize trafic, backend clients should subscribe to topics (at least message types) they are intererested to receive. And/or abrasive-ducks's forwarding backend module (still to be written) should filter out messages (at least UPDATE messages need not be forwarded to the backend process, only SUBSCRIBE messages; but not all queries will require all data?). → but this is probably premature optimization for now.

Messages keys and ids
---------------------

Messages keys identify a ressource that can be subscribed to.

Messages ids identify a document that can be updated. A document is also a ressource.

For documents, we should use the regular `<type>:<type-value>` id format, where `<type>` matches `[\w-]+`. The key format for documents is identical to the id format.

(( For non-document ressources (views, notifications from backends, …) we should use URL-style `/<type>/…` key format. )) This is subject to discussion, but at least provides an alternate anchor point for cases not provided here.

Existing types:

- `carrier` (tough-rate)
- `config:*` (`voice_prompts`,`registrant_host_to_server_mapping`)
- `destination` (tough-rate)
- `device` (autoprov)
- `domain` (DNS domain / endpoint domain)
- `endpoint`
- `emergency` (tough-rate)
- `gateway` (tough-rate)
- `number` (huge-play)
- `host`
- `list`
- `location`
- `number_domain`
- `prefix`
- `user` (spicy-action-user, probably obsolete, need to be replaced with a new type to store authorization)

- ? `voicemail_settings`, voicemail records ?

New types:

- `account` (wandering-country-view)
- `local-number` (wandering-country-view)
- `global-number` (wandering-country-view)
- `conference`
  - currently `conference:<conf_name>:participants` with subscribe = `conference:get-participants`, returns `conference:participants` → migrate to `conference:<conf_name>` with doc: {participants} [huge-play]
- `call:<call-id>`
  - currently `place-call` (UPDATE), `{endpoint,caller,_id ~ [\w-]+ }` optional `callee_name`, `callee_num`, `call_timeout`
  - also merge in the features of `call-to-conference` (UPDATE), `{endpoint,name,destination,_id}`, optional `language`, `timezone`
  - also merge in the features of `create-queuer-call` (UPDATE), `{agent,destination,_id,tags[]}`
  - merge with call state, `call:<call-id>` document; UPDATE is used to place call, SUBSCRIBE to retrieve call state (as provided by `report`, `queuer`(?)).
  - unify the documents (`report` documents → `call:` documents I suppose, `queuer` → `queuer`: documents?? or maybe `agent:`/`local-number:` documents etc.)

- `trace:<reference>` (nifty-ground)

- astonishing-competition billing indication?
- CDRs?
